<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Container Terminal</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <style>
      html,body { height:100%; margin:0; background:#000; color:#ddd; font-family: monospace; }
      #bar { background:#111; padding:6px 10px; display:flex; justify-content:space-between; align-items:center; font-size:12px; }
      #terminal { position:absolute; top:32px; left:0; right:0; bottom:0; padding:4px; }
      button { background:#222; color:#eee; border:1px solid #444; padding:4px 10px; cursor:pointer; }
      button:hover { background:#333; }
      #status { white-space:pre; overflow:hidden; text-overflow:ellipsis; }
    </style>
  </head>
  <body>
    <div id="bar">
      <div id="status">Connecting...</div>
      <div><button id="closeBtn">Close</button></div>
    </div>
    <div id="terminal"></div>
    <script>
      (function(){
        const p = new URLSearchParams(window.location.search);
        const file = p.get('file');
        const service = p.get('service');
        const statusEl = document.getElementById('status');
        const ip = p.get('ip');
        const action = p.get('action');
        if(!file || !service){
          statusEl.textContent = 'Missing file or service param';
          return;
        }
        if (action === 'log' && (!ip || !/^\d+\.\d+\.\d+\.\d+$/.test(ip))) {
          statusEl.textContent = 'Missing or invalid ip param for log action';
          return;
        }
        statusEl.textContent = 'Project: ' + service;

        // 2. MODIFY THE JAVASCRIPT
        const term = new window.Terminal({
            convertEol:true, 
            fontSize:13, 
            // Remove 'rows' to make it dynamic
            cursorBlink: true
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);

        term.open(document.getElementById('terminal'));
        
        let ws = null;

        function fit(){ 
          try {
            fitAddon.fit();
            // ðŸ‘‡ *** THIS IS THE NEW PART *** ðŸ‘‡
            // Send the new size to the server.
            const dims = { cols: term.cols, rows: term.rows };
            const resizeMessage = JSON.stringify({ type: 'resize', ...dims });
            // Only send if the websocket is open
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(resizeMessage);
            }
          } catch(e) {
            console.log(e);
          }
        }
        
        // Fit the terminal on initial load and on window resize
        fit();
        window.addEventListener('resize', fit);

        // Also use ResizeObserver for more reliable resizing
        const resizeObserver = new ResizeObserver(() => {
          fit();
        });
        resizeObserver.observe(document.getElementById('terminal'));

        // Trigger a resize event after setup to ensure proper initial sizing
        setTimeout(() => {
          window.dispatchEvent(new Event('resize'));
        }, 100);

  const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
  const params = { file, service };
  if (action) params.action = action;
  if (ip) params.ip = ip;
  const qs = new URLSearchParams(params).toString();
  const wsUrl = protocol + '://' + window.location.host + '/ws/attach?' + qs;

  // If action=log, render a cards UI and consume JSON log events from WS
  if (action === 'log') {
    // replace terminal area with a card list container
    const container = document.getElementById('terminal');
    container.innerHTML = `
      <div style="height:100%; display:flex; flex-direction:column;">
        <div style="padding:6px 8px; border-bottom:1px solid #222; display:flex; justify-content:space-between; align-items:center;">
          <div style="color:#7fffd4;">Following nginx comm.log for IP ${ip}</div>
          <div style="display:flex; gap:8px;">
            <button id="pauseBtn">Pause</button>
            <button id="clearBtn">Clear</button>
            <button id="closeBtnPopup">Close</button>
          </div>
        </div>
        <div id="cardList" style="flex:1; overflow:auto; padding:8px; display:flex; flex-direction:column; gap:8px;"></div>
      </div>`;

    const ws = new WebSocket(wsUrl);
    ws.onopen = () => { statusEl.textContent = 'Connected â€” receiving structured logs'; };
    let paused = false;
    const cardList = document.getElementById('cardList');
    const pauseBtn = document.getElementById('pauseBtn');
    const clearBtn = document.getElementById('clearBtn');
    const closeBtnPopup = document.getElementById('closeBtnPopup');
    pauseBtn.addEventListener('click', () => { paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
    clearBtn.addEventListener('click', () => { cardList.innerHTML = ''; });
    closeBtnPopup.addEventListener('click', () => { try { window.close(); } catch(e){} });

    function renderCard(obj) {
      const div = document.createElement('div');
      div.style.background = '#111';
      div.style.border = '1px solid #333';
      div.style.padding = '8px';
      div.style.cursor = 'pointer';
      div.innerHTML = `<div style="display:flex; justify-content:space-between;"><div style="font-weight:600; color:#9ad;">${obj.remote || '-'} -> ${obj.upstream || ip}</div><div style="color:${obj.status && obj.status>=200 && obj.status<400 ? '#7fffd4' : '#ff9d9d'}">${obj.status || '-'}</div></div><div style="font-size:12px; color:#aaa;">${obj.method || ''} ${obj.path || ''} â€¢ ${obj.time || ''}</div>`;
      div.addEventListener('click', () => {
        // show modal with details
        const modal = document.createElement('div');
        modal.style.position = 'fixed'; modal.style.left = 0; modal.style.top = 0; modal.style.right = 0; modal.style.bottom = 0; modal.style.background = 'rgba(0,0,0,0.6)'; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center'; modal.style.zIndex = 9999;
        const box = document.createElement('div'); box.style.background='#fff'; box.style.color='#000'; box.style.padding='12px'; box.style.maxWidth='90%'; box.style.maxHeight='90%'; box.style.overflow='auto';
        box.innerHTML = `<h3>Request details</h3><pre style="white-space:pre-wrap;">${JSON.stringify(obj, null, 2)}</pre><div style="text-align:right; margin-top:8px;"><button id='closeDetail'>Close</button></div>`;
        modal.appendChild(box);
        document.body.appendChild(modal);
        document.getElementById('closeDetail').addEventListener('click', ()=>{ document.body.removeChild(modal); });
      });
      cardList.prepend(div);
      // keep max 200 cards
      while (cardList.children.length > 200) cardList.removeChild(cardList.lastChild);
    }

    ws.onmessage = (ev) => {
      try {
        const d = typeof ev.data === 'string' ? ev.data : new TextDecoder().decode(ev.data);
        // expect JSON messages { log: {...} } or { info:... }
        const j = JSON.parse(d);
        if (j && j.log) {
          if (!paused) renderCard(j.log);
        } else if (j && j.info) {
          // optional info messages
          const infoDiv = document.createElement('div'); infoDiv.style.color='#7fffd4'; infoDiv.textContent = j.note || j.info || ''; cardList.prepend(infoDiv);
        } else if (j && j.error) {
          const err = document.createElement('div'); err.style.color='#ff9d9d'; err.textContent = (j.error + (j.detail?': '+j.detail:'')); cardList.prepend(err);
        }
      } catch (e) {
        // ignore malformed
      }
    };

    ws.onclose = () => { statusEl.textContent = 'Connection closed'; };
    return; // do not initialize xterm in this branch
  }

  // Non-log branch: initialize websocket and pipe to xterm
  ws = new WebSocket(wsUrl);
  ws.binaryType = 'arraybuffer';
  ws.onopen = () => {
    try { term.write('\x1b[32mConnected to ' + service + '\x1b[0m\r\n'); } catch(e){}
    try { fit(); } catch(e){}
  };
  ws.onmessage = (ev) => {
    try {
      const data = ev.data;
      if (typeof data === 'string') {
        // some server messages are JSON { error:.. }
        if (data.startsWith('{') && data.includes('error')) {
          try { const j = JSON.parse(data); if (j && j.error) { term.write('\r\n\x1b[31m' + j.error + '\x1b[0m\r\n'); return; } } catch(e){}
        }
        term.write(data);
      } else {
        term.write(new TextDecoder().decode(data));
      }
    } catch (e) { }
  };
  ws.onclose = () => {
    term.write('\r\n\x1b[31mConnection closed\x1b[0m');
    try {
      let seconds = 5;
      try { statusEl.textContent = 'Connection closed â€” closing in ' + seconds + 's'; } catch(e){}
      const countdown = setInterval(() => {
        seconds -= 1;
        try { statusEl.textContent = 'Connection closed â€” closing in ' + seconds + 's'; } catch(e){}
        if (seconds <= 0) clearInterval(countdown);
      }, 1000);
      setTimeout(() => { try { window.close(); } catch(e){} }, 5000);
    } catch(e){}
  };

  // manual close button (some browsers block window.close() for non-opened windows)
  try {
    const closeBtnTop = document.getElementById('closeBtn');
    if (closeBtnTop) closeBtnTop.addEventListener('click', ()=>{ try { window.close(); } catch(e){} });
  } catch(e){}

  term.onData(data => { try { if (ws && ws.readyState === WebSocket.OPEN) ws.send(data); } catch(e){} });
      })();
    </script>
  </body>
</html>