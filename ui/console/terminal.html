<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Container Terminal</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <style>
      html,body { height:100%; margin:0; background:#000; color:#ddd; font-family: monospace; }
      #bar { background:#111; padding:6px 10px; display:flex; justify-content:space-between; align-items:center; font-size:12px; }
      #terminal { position:absolute; top:32px; left:0; right:0; bottom:0; padding:4px; }
      button { background:#222; color:#eee; border:1px solid #444; padding:4px 10px; cursor:pointer; }
      button:hover { background:#333; }
      #status { white-space:pre; overflow:hidden; text-overflow:ellipsis; }
    </style>
  </head>
  <body>
    <div id="bar">
      <div id="status">Connecting...</div>
      <div><button id="closeBtn">Close</button></div>
    </div>
    <div id="terminal"></div>
    <script>
      (function(){
        const p = new URLSearchParams(window.location.search);
        const file = p.get('file');
        const service = p.get('service');
        const statusEl = document.getElementById('status');
        const ip = p.get('ip');
        const action = p.get('action');
        if(!file || !service){
          statusEl.textContent = 'Missing file or service param';
          return;
        }
        if (action === 'log' && (!ip || !/^\d+\.\d+\.\d+\.\d+$/.test(ip))) {
          statusEl.textContent = 'Missing or invalid ip param for log action';
          return;
        }
        statusEl.textContent = 'Project: ' + service;

        // 2. MODIFY THE JAVASCRIPT
        const term = new window.Terminal({
            convertEol:true, 
            fontSize:13, 
            // Remove 'rows' to make it dynamic
            cursorBlink: true
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);

        term.open(document.getElementById('terminal'));
        
        function fit(){ 
          try {
            fitAddon.fit();
            // ðŸ‘‡ *** THIS IS THE NEW PART *** ðŸ‘‡
            // Send the new size to the server.
            const dims = { cols: term.cols, rows: term.rows };
            const resizeMessage = JSON.stringify({ type: 'resize', ...dims });
            // Only send if the websocket is open
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(resizeMessage);
            }
          } catch(e) {
            console.log(e);
          }
        }
        
        // Fit the terminal on initial load and on window resize
        fit();
        window.addEventListener('resize', fit);

        // Also use ResizeObserver for more reliable resizing
        const resizeObserver = new ResizeObserver(() => {
          fit();
        });
        resizeObserver.observe(document.getElementById('terminal'));

        // Trigger a resize event after setup to ensure proper initial sizing
        setTimeout(() => {
          window.dispatchEvent(new Event('resize'));
        }, 100);

  const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
  const params = { file, service };
  if (action) params.action = action;
  // include ip when present so backend receives it
  if (ip) params.ip = ip;
  const qs = new URLSearchParams(params).toString();
  const wsUrl = protocol + '://' + window.location.host + '/ws/attach?' + qs;
        const ws = new WebSocket(wsUrl);
        ws.binaryType = 'arraybuffer';
        ws.onopen = () => { 
          term.write('\u001b[32mConnected to ' + service + '\u001b[0m\r\n'); 
          // Fit again in case of any layout shifts on connect
          fit();
        };
        ws.onmessage = ev => {
          const d = ev.data;
          if(typeof d === 'string'){
            if(d.startsWith('{') && d.includes('error')){
              try { const j = JSON.parse(d); if(j.error){ term.write('\r\n\u001b[31m' + j.error + '\u001b[0m\r\n'); return; } } catch(e){}
            }
            term.write(d);
          } else {
            term.write(new TextDecoder().decode(d));
          }
        };
        ws.onclose = () => { 
          term.write('\r\n\u001b[31mConnection closed\u001b[0m'); 
          try {
            // show status and start a 5s countdown to close the window
            let seconds = 5;
            try { statusEl.textContent = 'Connection closed â€” closing in ' + seconds + 's'; } catch(e){}
            const countdown = setInterval(() => {
              seconds -= 1;
              try { statusEl.textContent = 'Connection closed â€” closing in ' + seconds + 's'; } catch(e){}
              if (seconds <= 0) clearInterval(countdown);
            }, 1000);
            // attempt to close the window after 5 seconds
            setTimeout(() => {
              try { window.close(); } catch(e){}
            }, 5000);
          } catch(e){}
        };
        // manual close button (some browsers block window.close() for non-opened windows)
        try {
          const closeBtn = document.getElementById('closeBtn');
          if (closeBtn) closeBtn.addEventListener('click', ()=>{ try { window.close(); } catch(e){} });
        } catch(e){}
        term.onData(data => { try { ws.send(data); } catch(e){} });
      })();
    </script>
  </body>
</html>